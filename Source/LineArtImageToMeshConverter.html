<html>
<body>

<div>

	<h3>Line Art Image to Mesh Converter</h3>

	<p>
		Upload an image file to be converted to a 3D mesh,
		then use the W, A, S, and D keys to move the camera around.
	</p>

	<div>
		<label>Image File to Convert to Mesh:</label>
		<input
			id="inputMapImageFile"
			type="file"
			onchange="UiEventHandler.inputMapImageFile_OnChange(this);"
		></input>
	</div>

	<div>
		<label>Mesh:</label>
		<div id="divOutput">
			[none]
		</div>
	</div>

</div>

<script type="text/javascript">

// events

class UiEventHandler
{
	static inputMapImageFile_OnChange(inputMapImageFile)
	{
		var fileUploaded = inputMapImageFile.files[0];
		var fileReader = new FileReader();
		fileReader.onload = (event) =>
		{
			var fileUploadedAsDataUrl = event.target.result;
			var imageUploaded = new Image(fileUploadedAsDataUrl);
			imageUploaded.initialize
			(
				UiEventHandler.imageUploaded_OnLoad
			);
		};
		fileReader.readAsDataURL(fileUploaded);
	}

	static imageUploaded_OnLoad(event)
	{
		var imageMap = this;

		var world = new World
		(
			imageMap,
			new Camera
			(
				new Coords(200, 200, 0), // viewSize
				100, // focalLength
				new Coords(100, 100, -100), // pos
				new Orientation
				(
					new Coords(0, 0, 1),
					new Coords(0, 1, 0)
				)
			)
		);

		Globals.Instance.initialize(world);
	}
}

// Classes.

class Bounds
{
	constructor(min, max)
	{
		this.min = min;
		this.max = max;
	}

	containsPos(posToCheck)
	{
		return posToCheck.isInRangeMinMax(this.min, this.max);
	}

	overlapWith(bounds1)
	{
		var returnValue = false;

		var bounds = [ this, bounds1 ];

		for (var b = 0; b < bounds.length; b++)
		{
			var boundsThis = bounds[b];
			var boundsOther = bounds[1 - b];

			var doAllDimensionsOverlapSoFar = true;

			for (var d = 0; d < Coords.NumberOfDimensions; d++)
			{
				if 
				(
					boundsThis.max.dimension(d) < boundsOther.min.dimension(d)
					|| boundsThis.min.dimension(d) > boundsOther.max.dimension(d)
				)
				{
					doAllDimensionsOverlapSoFar = false;
					break;
				}
			}

			if (doAllDimensionsOverlapSoFar == true)
			{
				returnValue = true;
				break;
			}
		}

		return returnValue;
	}

	setFromPositions(positions)
	{
		this.min.overwriteWith(positions[0]);
		this.max.overwriteWith(positions[0]);

		for (var i = 1; i < positions.length; i++)
		{
			var pos = positions[i];

			for (var d = 0; d < Coords.NumberOfDimensions; d++)
			{
				var posDimension = pos.dimension(d);
				if (posDimension < this.min.dimension(d))
				{
					this.min.dimensionSet(d, posDimension);
				}
				if (posDimension > this.max.dimension(d))
				{
					this.max.dimensionSet(d, posDimension);
				}
			}
		}
	}
}

class Camera
{
	constructor(viewSize, focalLength, pos, orientation)
	{
		this.viewSize = viewSize;
		this.focalLength = focalLength;
		this.pos = pos;
		this.orientation = orientation;

		this.viewSizeHalf = this.viewSize.clone().divideScalar(2);
		this.transformCamera = new Transform_Camera(this);
	}
}

class Collision
{
	constructor(pos, distanceToCollision, colliders)
	{
		this.pos = pos;
		this.distanceToCollision = distanceToCollision;
		this.colliders = colliders;
	}

	static addCollisionsOfEdgeAndMeshToList(edge, mesh, listToAddTo)
	{
		for (var f = 0; f < mesh.faces.length; f++)
		{
			var face = mesh.faces[f];

			if (face.plane.normal.dotProduct(edge.direction) < 0)
			{
				var collision = this.findCollisionOfEdgeAndFace
				(
					edge,
					face
				);

				if (collision != null)
				{
					collision.colliders["Mesh"] = mesh;
					listToAddTo.push(collision);
				}
			}
		}

		return listToAddTo;
	}

	static findClosest(collisionsToCheck)
	{
		var collisionClosest = collisionsToCheck[0];
		
		for (var i = 1; i < collisionsToCheck.length; i++)
		{
			var collision = collisionsToCheck[i];
			if (collision.distanceToCollision < collisionClosest.distanceToCollision)
			{
				collisionClosest = collision;
			}
		}

		return collisionClosest;
	}

	static findCollisionOfEdgeAndFace(edge, face)
	{
		var returnValue = null;

		var collisionOfEdgeWithFacePlane = this.findCollisionOfEdgeAndPlane
		(
			edge,
			face.plane
		);

		if (collisionOfEdgeWithFacePlane != null)
		{
			var isWithinFace = this.isPosWithinFace
			(
				collisionOfEdgeWithFacePlane.pos, 
				face
			);

			if (isWithinFace == true)
			{
				returnValue = collisionOfEdgeWithFacePlane;
				returnValue.colliders["Face"] = face;
			}
		}

		return returnValue;
	}

	static findCollisionOfEdgeAndPlane(edge, plane)
	{
		var returnValue = null;

		var ray = new Ray(edge.vertices[0], edge.direction);

		var collisionOfRayAndPlane =
			this.findCollisionOfRayAndPlane(ray, plane);

		if 
		(
			collisionOfRayAndPlane != null 
			&& collisionOfRayAndPlane.distanceToCollision <= edge.length
		)
		{
			returnValue = collisionOfRayAndPlane;
			returnValue.colliders["Edge"] = edge;
		}

		return returnValue;
	}

	static findCollisionOfRayAndFace(ray, face)
	{
		var returnValue = null;

		var collisionOfRayAndPlane =
			this.findCollisionOfRayAndPlane(ray, face.plane);

		if 
		(
			collisionOfRayAndPlane != null 
			&& this.isPosWithinFace(collisionOfRayAndPlane.pos, face)
		)
		{
			returnValue = collisionOfRayAndPlane;
			returnValue.colliders["Face"] = face;
		}

		return returnValue;
	}

	static findCollisionOfRayAndPlane(ray, plane)
	{
		var returnValue = null;

		var distanceToCollision = 
			(
				plane.distanceFromOrigin 
				- plane.normal.dotProduct(ray.vertex)
			)
			/ plane.normal.dotProduct(ray.direction);

		if (distanceToCollision >= 0)
		{
			var collisionPos =
				ray.direction
					.clone()
					.multiplyScalar(distanceToCollision)
					.add(ray.vertex);

			var colliders = [];
			colliders["Ray"] = ray;
			colliders["Plane"] = plane;
	
			returnValue = new Collision
			(
				collisionPos,
				distanceToCollision,
				colliders
			);
		}

		return returnValue;
	}

	static isPosWithinFace(posToCheck, face)
	{
		var displacementFromVertex0ToCollision = new Coords();

		var isPosWithinAllEdgesOfFaceSoFar = true;
		var edgeFromFaceTransverse = new Coords();

		for (var e = 0; e < face.edges.length; e++)
		{
			var edgeFromFace = face.edges[e];
			edgeFromFaceTransverse
				.overwriteWith(edgeFromFace.direction)
				.crossProduct(face.plane.normal);

			displacementFromVertex0ToCollision
				.overwriteWith(posToCheck)
				.subtract(edgeFromFace.vertices[0]);

			var displacementProjectedAlongEdgeTransverse = 
				displacementFromVertex0ToCollision
					.dotProduct(edgeFromFaceTransverse);

			if (displacementProjectedAlongEdgeTransverse > 0)
			{
				isPosWithinAllEdgesOfFaceSoFar = false;
				break;
			}
		}

		return isPosWithinAllEdgesOfFaceSoFar;
	}

	static findDistanceOfPositionAbovePlane(posToCheck, plane)
	{
		var returnValue = posToCheck.dotProduct
		(
			plane.normal
		) - plane.distanceFromOrigin;

		return returnValue;
	}
}

class Color
{
	constructor(componentsRGBA)
	{
		this.componentsRGBA = componentsRGBA;

		this.systemColor = 
			"rgba(" 
			+ this.componentsRGBA[0] + "," 
			+ this.componentsRGBA[1] + ","
			+ this.componentsRGBA[2] + ","
			+ (this.componentsRGBA[3] / 255)
			+ ")";
	}

	equals(other)
	{
		var returnValue = true;

		for (var i = 0; i < this.componentsRGBA.length; i++)
		{
			var componentThis = this.componentsRGBA[i];
			var componentOther = other.componentsRGBA[i];

			if (componentThis != componentOther)
			{
				returnValue = false;
				break;
			}
		}

		return returnValue;
	}

	hue()
	{
		var returnValue = null;

		var red = this.componentsRGBA[0];
		var green = this.componentsRGBA[1];
		var blue = this.componentsRGBA[2];

		var hue = null;
		var saturation = null;
		var value = null;

		var rgbComponentMin = red;
		if (rgbComponentMin > green)
		{
			rgbComponentMin = green;
		}
		if (rgbComponentMin > blue)
		{
			rgbComponentMin = blue;
		}

		var rgbComponentMax = red;
		if (rgbComponentMax < green)
		{
			rgbComponentMax = green;
		}
		if (rgbComponentMax < blue)
		{
			rgbComponentMax = blue;
		}

		var rgbComponentRange = rgbComponentMax - rgbComponentMin;

		value = rgbComponentMax;

		if (rgbComponentRange == 0)
		{
			hue = 0;
		   	saturation = 0;
		}
		else
		{
			if (rgbComponentMax == red)
			{
				hue = Math.abs(green - blue) / rgbComponentRange;
			}
			else if (rgbComponentMax == green)
			{
				hue = Math.abs(blue - red) / rgbComponentRange + (1 / 3);
			}
			else if (rgbComponentMax == blue)
			{
				hue = Math.abs(red - green) / rgbComponentRange + (2 / 3);
			}

			saturation = rgbComponentRange / value;
		}

		return hue;
	}

	luminance()
	{
		var returnValue = Math.floor
		(
			(
				this.componentsRGBA[0]
				+ this.componentsRGBA[1]
				+ this.componentsRGBA[2]
			) 
			/ 3
		);

		return returnValue;
	}
}

class Coords
{
	constructor(x, y, z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}

	static NumberOfDimensions = 3;

	add(other)
	{
		this.x += other.x;
		this.y += other.y;
		this.z += other.z;
		return this;
	}

	clone()
	{
		return new Coords(this.x, this.y, this.z);
	}

	crossProduct(other)
	{
		return this.overwriteWithDimensions
		(
			this.y * other.z - this.z * other.y,
			this.z * other.x - this.x * other.z,
			this.x * other.y - this.y * other.x
		);
	}

	dimension(dimensionIndex)
	{
		var returnValue;

		if (dimensionIndex == 0)
		{
			returnValue = this.x;
		}
		else if (dimensionIndex == 1)
		{
			returnValue = this.y;
		}
		else
		{
			returnValue = this.z;
		}

		return returnValue;
	}

	dimensionSet(dimensionIndex, value)
	{
		if (dimensionIndex == 0)
		{
			this.x = value;
		}
		else if (dimensionIndex == 1)
		{
			this.y = value;
		}
		else
		{
			this.z = value;
		}

		return this;
	}

	divide(other)
	{
		this.x /= other.x;
		this.y /= other.y;
		this.z /= other.z;
		return this;
	}

	divideScalar(scalar)
	{
		this.x /= scalar;
		this.y /= scalar;
		this.z /= scalar;
		return this;
	}

	dotProduct(other)
	{
		return this.x * other.x + this.y * other.y + this.z * other.z;
	}

	equals(other)
	{
		var returnValue = 
		(
			this.x == other.x
			&& this.y == other.y
			&& this.z == other.z
		);
		return returnValue;
	}

	equalsXY(other)
	{
		var returnValue = 
		(
			this.x == other.x
			&& this.y == other.y
		);
		return returnValue;
	}

	isInRangeMinMax(min, max)
	{
		var returnValue =
		(
			this.x >= min.x
			&& this.y >= min.y
			&& this.z >= min.z
			&& this.x <= max.x
			&& this.y <= max.y
			&& this.z <= max.z
		);

		return returnValue;
	}

	isInRangeMax(max)
	{
		var returnValue =
		(
			this.x >= 0
			&& this.y >= 0
			&& this.z >= 0
			&& this.x <= max.x
			&& this.y <= max.y
			&& this.z <= max.z
		);

		return returnValue;
	}

	magnitude()
	{
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	}


	magnitudeOrthogonal()
	{
		return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
	}

	multiply(other)
	{
		this.x *= other.x;
		this.y *= other.y;
		this.z *= other.z;
		return this;
	}

	multiplyScalar(scalar)
	{
		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		return this;
	}

	normalize()
	{
		return this.divideScalar(this.magnitude());
	}

	overwriteWith(other)
	{
		this.x = other.x;
		this.y = other.y;
		this.z = other.z;
		return this;
	}

	overwriteWithDimensions(x, y, z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
		return this;
	}

	subtract(other)
	{
		this.x -= other.x;
		this.y -= other.y;
		this.z -= other.z;
		return this;
	}

	toString()
	{
		var returnValue =
			"(" 
			+ this.x + ","
			+ this.y + ","
			+ this.z
			+ ")";

		return returnValue;
	}
}

class DisplayHelper
{
	clear()
	{
		var g = this.graphics;

		g.fillStyle = "White";
		g.fillRect
		(
			0, 0,
			this.viewSizeInPixels.x,
			this.viewSizeInPixels.y
		);

		g.strokeStyle = "LightGray";
		g.lineWidth = 1;
		g.lineJoin = null;
		g.strokeRect
		(
			0, 0,
			this.viewSizeInPixels.x,
			this.viewSizeInPixels.y
		);
	}

	drawImage(image, drawPosInPixels)
	{
		this.graphics.drawImage
		(
			image.systemImage,
			drawPosInPixels.x,
			drawPosInPixels.y
		);
	}

	drawMeshAbsolute(mesh)
	{
		this.graphics.strokeStyle = mesh.color;
		this.graphics.lineWidth = 8;
		this.graphics.lineJoin = "round";
		
		for (var f = 0; f < mesh.vertexIndicesForFaces.length; f++)
		{
			var vertexIndicesForFace = mesh.vertexIndicesForFaces[f];

			this.graphics.beginPath();

			for (var vi = 0; vi < vertexIndicesForFace.length; vi++)
			{
				var vertexIndex = vertexIndicesForFace[vi];
				var vertex = mesh.vertices[vertexIndex];

				if (vi == 0)
				{
					this.graphics.moveTo
					(
						vertex.x,
						vertex.y
					);
				}
				else
				{
					this.graphics.lineTo
					(
						vertex.x,
						vertex.y
					);
				}
			}

			this.graphics.closePath();
			this.graphics.stroke();
		}
	}

	drawMeshForCamera(mesh, camera)
	{
		this.graphics.strokeStyle = mesh.color;
		this.graphics.fillStyle = mesh.color;

		var drawPos = new Coords(0, 0, 0);
		this.graphics.beginPath();

		var vertexIndicesForFaces = mesh.vertexIndicesForFaces;
		for (var f = 0; f < vertexIndicesForFaces.length; f++)
		{
			var vertexIndicesForFace = vertexIndicesForFaces[f];

			for (var vi = 0; vi < vertexIndicesForFace.length; vi++)
			{
				var vertexIndex = vertexIndicesForFace[vi];
				var vertex = mesh.vertices[vertexIndex];

				drawPos.overwriteWith(vertex);
				camera.transformCamera.applyToCoords(drawPos);

				if (vi == 0)
				{
					this.graphics.moveTo(drawPos.x, drawPos.y);
				}
				else
				{
					this.graphics.lineTo(drawPos.x, drawPos.y);
				}

				if (this.isDebugModeActive == true)
				{
					this.graphics.fillText
					(
						vertex.toString(),
						drawPos.x, 
						drawPos.y
					);
				}
				
			}

			this.graphics.closePath();
			this.graphics.stroke();
		}
	}


	drawWorld(world)
	{
		this.clear();

		//this.drawImage(world.imageForMap, new Coords(0, 0));

		var meshesForMap = world.meshesForMap;
		for (var i = 0; i < meshesForMap.length; i++)
		{
			var mesh = meshesForMap[i];
			//this.drawMeshAbsolute(mesh);
			this.drawMeshForCamera(mesh, world.camera);
		}
	}

	initialize(viewSizeInPixels)
	{
		this.viewSizeInPixels = viewSizeInPixels;

		var d = document;

		var canvas = d.createElement("canvas");
		canvas.width = this.viewSizeInPixels.x;
		canvas.height = this.viewSizeInPixels.y;

		this.graphics = canvas.getContext("2d");

		var divOutput = d.getElementById("divOutput");
		divOutput.innerHTML = "";
		divOutput.appendChild(canvas);
	}
}

class Edge
{
	constructor(vertices)
	{
		this.vertices = vertices;
		this.displacement =
			this.vertices[1]
				.clone()
				.subtract(this.vertices[0] );
		this.length = this.displacement.magnitude();
		this.direction =
			this.displacement
				.clone()
				.divideScalar(this.length);
	}

	isConnectedToXY(other)
	{
		var returnValue = false;

		for (var i = 0; i < this.vertices.length; i++)
		{
			var vertexThis = this.vertices[i];

			for (var j = 0; j < other.vertices.length; j++)
			{
				var vertexOther = other.vertices[j];

				var verticesAreEqual =
					vertexThis.equalsXY(vertexOther);

				if (verticesAreEqual)
				{
					returnValue = true;
					break;
				}
			}
		}

		return returnValue;

	}

	mergeWith(other)
	{
		var returnValue = null; 

		var codirectionalityXY = Math.abs
		(
			this.direction.clone().dimensionSet(2, 0).normalize().dotProduct
			(
				other.direction.clone().dimensionSet(2,0).normalize()
			)
		);

		var codirectionalityThreshold = 1;

		if (codirectionalityXY >= codirectionalityThreshold)
		{
			for (var i = 0; i < this.vertices.length; i++)
			{
				var vertexThis = this.vertices[i];

				for (var j = 0; j < other.vertices.length; j++)
				{
					var vertexOther = other.vertices[j];
					
					var areVerticesEqual = vertexThis.equals
					(
						vertexOther
					);

					if (areVerticesEqual == true)
					{	
						var vertexThisOuter = this.vertices[1 - i];
						var vertexOtherOuter = other.vertices[1 - j];

						if (vertexThis.z == 0)
						{
							returnValue = new Edge
							([
								vertexThisOuter,
								vertexOtherOuter
							]);
						}
						
						break;
					}
				}
			}
		}

		return returnValue;	
	}
}

class Face
{
	constructor(vertices)
	{
		this.vertices = vertices;
		this.bounds = new Bounds(new Coords(0, 0, 0), new Coords(0, 0, 0));

		this.plane = new Plane
		(
			new Coords(), 
			new Coords()
		).fromPoints
		(
			this.vertices[0],
			this.vertices[1],
			this.vertices[2]
		);

		this.edges = [];

		for (var i = 0; i < this.vertices.length; i++)
		{
			var iNext = i + 1;
			if (iNext >= this.vertices.length)
			{
				iNext = 0;
			}

			var vertexPos = this.vertices[i];
			var vertexPosNext = this.vertices[iNext];

			var edge = new Edge([vertexPos, vertexPosNext]);

			this.edges.push(edge);
		}

		this.bounds.setFromPositions(this.vertices);
	}

	recalculateDerivedValues()
	{
		this.plane.fromPoints
		(
			this.vertices[0].pos,
			this.vertices[1].pos,
			this.vertices[2].pos
		);

		for (var i = 0; i < this.edges.length; i++)
		{
			var edge = this.edges[i];

			edge.recalculateDerivedValues();
		}

		var vertexPositions = Vertex.addPositionsOfManyToList(this.vertices, []);
		this.bounds.setFromPositions(vertexPositions);
	}
}

class Globals
{
	static Instance = new Globals();

	initialize(world)
	{
		this.world = world;
		this.world.initialize();

		this.displayHelper = new DisplayHelper();
		this.displayHelper.initialize(this.world.camera.viewSize);
		this.displayHelper.drawWorld(this.world);

		this.inputHelper = new InputHelper();
		this.inputHelper.initialize();
	}
}

class Image
{
	constructor(source)
	{
		this.source = source;
	}

	colorOfPixelAtPos(pixelPos)
	{
		var imageDataForPixel = this.graphics.getImageData
		(
			pixelPos.x, pixelPos.y, 1, 1
		);
		var pixelComponentsAsUint8ClampedArray = imageDataForPixel.data;
		var pixelComponentsRGBA = 
		[
			pixelComponentsAsUint8ClampedArray[0],
			pixelComponentsAsUint8ClampedArray[1],
			pixelComponentsAsUint8ClampedArray[2],
			pixelComponentsAsUint8ClampedArray[3]
		];
		var returnValue = new Color(pixelComponentsRGBA);
		return returnValue;
	}

	initialize(callback)
	{
		this.systemImage = document.createElement("img");
		this.systemImage.src = this.source;
		this.systemImage.onload = this.initialize_2.bind(this, callback);
	}

	initialize_2(callback)
	{
		this.size = new Coords
		(
			this.systemImage.width,
			this.systemImage.height
		);

		var canvas = document.createElement("canvas");
		canvas.width = this.size.x;
		canvas.height = this.size.y;
		this.graphics = canvas.getContext("2d");
		this.graphics.drawImage(this.systemImage, 0, 0);

		callback.call(this);
	}
}

class ImageToMeshParser
{
	constructor(colorToIgnore, colorForWall, wallHeight, depthMax)
	{
		this.colorToIgnore = colorToIgnore;
		this.colorForWall = colorForWall;
		this.wallHeight = wallHeight;
		this.depthMax = depthMax;
	}

	imageToMeshes(image)
	{
		var pointsOnWalls = this.imageToMeshes_1_ImageToPoints(image);

		var edgesForWalls = this.imageToMeshes_2_WallPointsToEdges(pointsOnWalls);

		edgesForWalls = this.imageToMeshes_3_EdgesMerge(edgesForWalls);

		edgesForWalls = this.imageToMeshes_4_EdgesCullDiagonalCorners(edgesForWalls);

		var edgeGroupsConnected = this.imageToMeshes_5_EdgesConnect(edgesForWalls);

		var meshesForWalls = this.imageToMeshes_6_EdgeGroupsToMeshes(edgeGroupsConnected);

		return meshesForWalls;
	}

	imageToMeshes_1_ImageToPoints(image)
	{
		var mapSize = image.size;

		var pointsOnWalls = [];

		var pixelPos = new Coords(0, 0, 0);

		for (var y = 0; y < mapSize.y; y++)
		{
			pixelPos.y = y;

			for (var x = 0; x < mapSize.x; x++)
			{
				pixelPos.x = x;

				var pixelColor = image.colorOfPixelAtPos(pixelPos);

				if (pixelColor.equals(this.colorToIgnore) == true)
				{
					// do nothing
				}
				else
				{
					var depth = 
						pixelColor.hue() 
						* this.depthMax;

					pointsOnWalls.push
					(
						pixelPos.clone().dimensionSet(2, depth)
					);
				}
			}
		}

		return pointsOnWalls;
	}

	imageToMeshes_2_WallPointsToEdges(pointsOnWalls)
	{
		var edgesForWalls = [];

		var distanceThreshold = 2;

		for (var i = 0; i < pointsOnWalls.length; i++)
		{
			var pointThis = pointsOnWalls[i];

			var pointsClosestSoFar = [];
			var distancesToPointsClosestSoFar = [];

			for (var j = i + 1; j < pointsOnWalls.length; j++)
			{
				var pointOther = pointsOnWalls[j];
				
				var distanceBetweenPointsXY = pointThis.clone().subtract
				(
					pointOther
				).dimensionSet
				(
					2, 0
				).magnitude();

				if (distanceBetweenPointsXY < distanceThreshold)
				{	
					var d;
					for (d = 0; d < distancesToPointsClosestSoFar.length; d++)
					{
						var distance = distancesToPointsClosestSoFar[d];
						if (distanceBetweenPointsXY <= distance)
						{
							break;
						}
					}

					distancesToPointsClosestSoFar.splice
					(
						d, 0, distanceBetweenPointsXY
					);
					pointsClosestSoFar.splice
					(
						d, 0, pointOther
					);
				}
			}

			for (var d = 0; d < pointsClosestSoFar.length; d++)
			{
				var pointOther = pointsClosestSoFar[d];
				var edgeForPoints = new Edge
				([
					pointThis,
					pointOther
				]);
				edgesForWalls.push(edgeForPoints);
			}
		}

		return edgesForWalls;
	}

	imageToMeshes_3_EdgesMerge(edgesForWalls)
	{
		var wereAnyEdgesMergedInPreviousRun = true;

		while (wereAnyEdgesMergedInPreviousRun == true)
		{
			wereAnyEdgesMergedInPreviousRun = false;

			var edgesForWallsNext = [];

			for (var i = 0; i < edgesForWalls.length; i++)
			{
				var edgeThis = edgesForWalls[i];

				var j;
				var edgeMerged = null;

				for (j = i + 1; j < edgesForWalls.length; j++)
				{
					var edgeOther = edgesForWalls[j];

					edgeMerged = edgeThis.mergeWith
					(
						edgeOther
					);

					if (edgeMerged != null)
					{
						break;
					}
				}

				if (edgeMerged != null)
				{
					edgesForWallsNext.push(edgeMerged);
					wereAnyEdgesMergedInPreviousRun = true;
					edgesForWalls.splice(j, 1);
				}
				else
				{
					edgesForWallsNext.push(edgeThis);
				}
			}

			edgesForWalls = edgesForWallsNext;
		}

		return edgesForWalls;
	}	

	imageToMeshes_4_EdgesCullDiagonalCorners(edgesForWalls)
	{
		var indicesOfEdgesToCull = [];

		for (var e = 0; e < edgesForWalls.length; e++)
		{
			var edgeForWall = edgesForWalls[e];

			var magnitudeOrthogonal = edgeForWall.displacement.magnitudeOrthogonal();

			if (magnitudeOrthogonal == 2)
			{
				indicesOfEdgesToCull.splice(0, 0, e);
			}
		}

		for (var i = 0; i < indicesOfEdgesToCull.length; i++)
		{
			var indexOfEdgeToCull = indicesOfEdgesToCull[i];
			edgesForWalls.splice(indexOfEdgeToCull, 1);
		}

		return edgesForWalls;
	}

	imageToMeshes_5_EdgesConnect(edgesForWalls)
	{
		var edgeGroupsConnected = [];

		for (var i = 0; i < edgesForWalls.length; i++)
		{
			var edgeThis = edgesForWalls[i];
			var edgeThisAsGroup = [ edgeThis ];
			edgeGroupsConnected.push(edgeThisAsGroup);
		}

		var wereAnyGroupsMerged = true;

		while (wereAnyGroupsMerged == true)
		{
			wereAnyGroupsMerged = false;

			for (var g = 0; g < edgeGroupsConnected.length; g++)
			{
				var edgeGroupThis = edgeGroupsConnected[g];

				for (var h = g + 1; h < edgeGroupsConnected.length; h++)
				{
					var edgeGroupOther = edgeGroupsConnected[h];

					var areGroupsConnected = false;

					for (var i = 0; i < edgeGroupThis.length; i++)
					{
						var edgeThis = edgeGroupThis[i];
						
						for (var j = 0; j < edgeGroupOther.length; j++)
						{
							var edgeOther = edgeGroupOther[j];
							var areEdgesConnectedXY = edgeThis.isConnectedToXY
							(
								edgeOther
							);

							if (areEdgesConnectedXY == true)
							{
								areGroupsConnected = true;
								wereAnyGroupsMerged = true;
								break;
							}
						}
	
						if (areGroupsConnected == true)
						{
							break;
						}
					}
	
					if (areGroupsConnected == true)
					{
						for (var k = 0; k < edgeGroupOther.length; k++)
						{
							var edgeToAppend = edgeGroupOther[k];
							edgeGroupThis.push(edgeToAppend);
						}
						edgeGroupsConnected.splice(h, 1);
						break;
					}
				}
			}
		}

		return edgeGroupsConnected;
	}

	imageToMeshes_6_EdgeGroupsToMeshes(edgeGroupsConnected)
	{
		var returnValues = [];

		for (var g = 0; g < edgeGroupsConnected.length; g++)
		{
			var edgesInGroup = edgeGroupsConnected[g];

			var verticesMerged = [];
			var vertexIndicesForFaces = [];

			for (var e = 0; e < edgesInGroup.length; e++)
			{
				var edge = edgesInGroup[e];

				for (var i = 0; i < edge.vertices.length; i++)
				{
					var edgeVertex = edge.vertices[i];

					if (verticesMerged.indexOf(edgeVertex) == -1)
					{
						var hasEdgeVertexBeenMerged = false;

						for (var j = 0; j < verticesMerged.length; j++)
						{
							var vertexMerged = verticesMerged[j];
							if (vertexMerged.equals(edgeVertex) )
							{
								edge.vertices[i] = vertexMerged;
								hasEdgeVertexBeenMerged = true;
								break;
							}
						}
	
						if (hasEdgeVertexBeenMerged == false)
						{
							verticesMerged.push(edgeVertex);
						}
					}
				}
			}

			var numberOfCorners = verticesMerged.length;

			for (var v = 0; v < numberOfCorners; v++)
			{
				var vertex = verticesMerged[v];
				var vertexAbove = vertex.clone().dimensionSet
				(
					2, 0 - this.wallHeight
				);
				verticesMerged.push(vertexAbove);
			}

			var vertexIndicesForFaces = [];

			for (var e = 0; e < edgesInGroup.length; e++)
			{
				var edge = edgesInGroup[e];
				var edgeVertices = edge.vertices;

				var vertexIndicesForFace = 
				[
					verticesMerged.indexOf(edgeVertices[0]),
					verticesMerged.indexOf(edgeVertices[1]),
				];

				vertexIndicesForFace.push
				(
					vertexIndicesForFace[1] + numberOfCorners
				);
				vertexIndicesForFace.push
				(
					vertexIndicesForFace[0] + numberOfCorners
				);

				vertexIndicesForFaces.push(vertexIndicesForFace);
			}

			var hueMax = 360;
			var hue = Math.floor(Math.random() * hueMax);
			var meshColor = "hsl(" + hue + ", 100%, 50%)";

			var mesh = new Mesh
			(
				"Mesh" + i,
				meshColor,
				verticesMerged,
				vertexIndicesForFaces
			);

			returnValues.push(mesh);
		}

		return returnValues;
	}
}

class InputHelper
{
	initialize()
	{
		var d = document;
		d.body.onkeydown = this.handleEventKeyDown.bind(this);
		d.body.onkeyup = this.handleEventKeyUp.bind(this);
	}

	// events

	handleEventKeyDown(event)
	{
		this.keyCodePressed = event.keyCode;
		Globals.Instance.world.update();
	}

	handleEventKeyUp(event)
	{
		this.keyCodePressed = null;
		Globals.Instance.world.update();
	}
}

class Mesh
{
	constructor(name, color, vertices, vertexIndicesForFaces)
	{
		this.name = name;
		this.color = color;
		this.vertices = vertices;
		this.vertexIndicesForFaces = vertexIndicesForFaces;
	}

	face(faceIndex)
	{
		var verticesForFace = [];
		var vertexIndicesForFace = this.vertexIndicesForFaces[faceIndex];
		for (var vi = 0; vi < vertexIndicesForFace.length; vi++)
		{
			var vertexIndex = vertexIndicesForFace[vi];
			var vertex = this.vertices[vertexIndex];
			verticesForFace.push(vertex);
		}

		var returnValue = new Face(verticesForFace);

		return returnValue;
	}
}

class Plane
{
	constructor(normal, distanceFromOrigin)
	{
		this.normal = normal;
		this.distanceFromOrigin = distanceFromOrigin;
	}

	static DisplacementFromPoint0To1 = new Coords(0, 0, 0);

	equals(other)
	{
		var returnValue = 
		(
			this.normal.equals(other.normal) 
			&& this.distanceFromOrigin == other.distanceFromOrigin
		);

		return returnValue;
	}

	fromPoints(point0, point1, point2)
	{
		var displacementFromPoint0To1 = Plane.DisplacementFromPoint0To1;
		displacementFromPoint0To1.overwriteWith
		(
			point1
		).subtract
		(
			point0
		);

		var displacementFromPoint0To2 = point2.clone().subtract(point0);

		this.normal.overwriteWith
		(
			displacementFromPoint0To1
		).crossProduct
		(
			displacementFromPoint0To2
		).normalize();

		this.distanceFromOrigin = this.normal.dotProduct
		(
			point0
		);

		return this;
	}

}

class Orientation
{
	constructor(forward, down)
	{
		this.forward = forward.clone().normalize();
		this.down = down.clone().normalize();
		this.right = this.down.clone().crossProduct(this.forward).normalize();
	}
}

class Ray
{
	constructor(vertex, direction)
	{
		this.vertex = vertex;
		this.direction = direction;
	}
}

class Transform_Camera
{
	constructor(camera)
	{
		this.camera = camera;

		this.transformTranslateInverse = new Transform_TranslateInverse(this.camera.pos);
		this.transformOrient = new Transform_Orient(this.camera.orientation);
		this.transformPerspective = new Transform_Perspective(this.camera.focalLength);
		this.transformTranslateCenter = new Transform_Translate(this.camera.viewSizeHalf);
	}

	applyToCoords(coordsToTransform)
	{
		this.transformTranslateInverse.applyToCoords(coordsToTransform);

		this.transformOrient.applyToCoords(coordsToTransform);

		this.transformPerspective.applyToCoords(coordsToTransform);

		this.transformTranslateCenter.applyToCoords(coordsToTransform);

		return coordsToTransform;
	}
}

class Transform_Perspective
{
	constructor(focalLength)
	{
		this.focalLength = focalLength;
	}

	applyToCoords(coordsToTransform)
	{
		var distanceFromFocus = coordsToTransform.z;
		coordsToTransform.multiplyScalar
		(
			this.focalLength
		).divideScalar
		(
			distanceFromFocus
		);
		coordsToTransform.z = distanceFromFocus;

		return coordsToTransform;
	}
}

class Transform_Translate
{
	constructor(displacement)
	{
		this.displacement = displacement;
	}

	applyToCoords(coordsToTransform)
	{
		return coordsToTransform.add(this.displacement);
	}
}

class Transform_TranslateInverse
{
	constructor(displacement)
	{
		this.displacement = displacement;
	}

	applyToCoords(coordsToTransform)
	{
		return coordsToTransform.subtract(this.displacement);
	}
}

class Transform_Orient
{
	constructor(orientation)
	{
		this.orientation = orientation;
	}

	applyToCoords(coordsToTransform)
	{
		return coordsToTransform.overwriteWithDimensions
		(
			this.orientation.right.dotProduct(coordsToTransform),
			this.orientation.down.dotProduct(coordsToTransform),
			this.orientation.forward.dotProduct(coordsToTransform)
		);
	}
}

class World
{
	constructor(imageForMap, camera)
	{
		this.imageForMap = imageForMap;
		this.camera = camera;
	}

	initialize()
	{
		var colorToIgnore = new Color([255, 255, 255, 255]);
		var colorForWall = new Color([0, 0, 0, 255]);
		var wallHeight = 10;
		var parser = new ImageToMeshParser
		(
			colorToIgnore,
			colorForWall, 
			wallHeight,
			10 // depthMax
		);
		this.meshesForMap = parser.imageToMeshes(this.imageForMap);
	}

	update()
	{
		var inputHelper = Globals.Instance.inputHelper;
		var keyCodePressed = inputHelper.keyCodePressed;

		if (keyCodePressed != null)
		{
			var cameraPos = this.camera.pos;
			var cameraMoveAxes = new Orientation
			(
				new Coords(0, 0, 1),
				new Coords(0, 1, 0)
			);
			var cameraSpeed = 4;

			if (keyCodePressed == 65) // a
			{
				cameraPos.add
				(
					cameraMoveAxes.right.clone().multiplyScalar
					(
						0 - cameraSpeed
					)
				);
			}
			else if (keyCodePressed == 68) // d
			{
				cameraPos.add
				(
					cameraMoveAxes.right.clone().multiplyScalar
					(
						cameraSpeed
					)
				);
			}
			else if (keyCodePressed == 70) // f
			{
				cameraPos.add
				(
					cameraMoveAxes.forward.clone().multiplyScalar
					(
						cameraSpeed
					)
				);
			}
			else if (keyCodePressed == 82) // r
			{
				cameraPos.add
				(
					cameraMoveAxes.forward.clone().multiplyScalar
					(
						0 - cameraSpeed
					)
				);
			}
			else if (keyCodePressed == 83) // s
			{
				cameraPos.add
				(
					cameraMoveAxes.down.clone().multiplyScalar
					(
						cameraSpeed
					)
				);
			}
			else if (keyCodePressed == 87) // w
			{
				cameraPos.add
				(
					cameraMoveAxes.down.clone().multiplyScalar
					(
						0 - cameraSpeed
					)
				);
			}
		}

		Globals.Instance.displayHelper.drawWorld(this);
	}
}

</script>
</body>
</html>